package
{
	import com.vsdevelop.air.extension.glfw.ANEGLFW;
	import com.vsdevelop.air.extension.glfw.Gl;
	import com.vsdevelop.air.extension.glfw.Glfw;
	import flash.display.Bitmap;
	import flash.display.BitmapData;
	import ui.text.TextRenderer;
	
	import ui.core.UIManager;
	import ui.components.Button;
	import ui.components.Image;
	import ui.events.UIEvent;
	import ui.test.UITestCase;
	import ui.state.FpsMonitor;
	import flash.display.Screen;
	import flash.display.BitmapData;
	import flash.events.Event;
	import flash.display.Sprite;
	import flash.display.StageAlign;
	import flash.display.StageScaleMode;
	import flash.events.MouseEvent;
	import flash.geom.Point;
	import flash.text.TextField;
	import flash.text.TextFormat;
	import flash.utils.getTimer;
	import flash.utils.Timer;
	import flash.events.TimerEvent;
	
	/**
	 * UI框架测试主类
	 * 集成ANEGLFW扩展和UI框架，提供完整的测试环境
	 * @author Generated by AI Assistant
	 */
	public class UITestMain extends Sprite
	{
		// GLFW相关
		private var windowIntPtr:Number;
		private var glWidth:int = 800;
		private var glHeight:int = 600;
		private var isAIRWindow:Boolean = true;
		
		// UI框架相关
		private var _uiManager:UIManager;
		private var _testCase:UITestCase;
		
		// 测试组件
		private var _testButton1:Button;
		private var _testButton2:Button;
		private var _testButton3:Button;
		private var _testImage:Image;
		
		// 背景组件
		private var _backgroundImage:Image;
		private var _backgroundTimer:Timer;
		private var _currentBackgroundIndex:int = 0;
		private var _backgroundUrls:Vector.<String>;
		
		// 定时器管理
		private var _activeTimers:Vector.<Timer> = new Vector.<Timer>();
		
		// 界面元素
		private var _note:TextField;
		private var _statusText:TextField;
		
		private var fpsMonitor:FpsMonitor;
		
		[Embed(source = "../assets/test.png")]
		public var imgBitmap:Class;
		
		/**
		 * 构造函数
		 */
		public function UITestMain():void
		{
			stage.align = StageAlign.TOP_LEFT;
			stage.scaleMode = StageScaleMode.NO_SCALE;
			
			// 设置事件监听器
			stage.nativeWindow.addEventListener(Event.CLOSING, closeApp);
			stage.addEventListener(Event.RESIZE, stageResize);
			
			if (ANEGLFW.getInstance().isSupported)
			{
				trace("GLFW版本: " + Glfw.glfwGetVersionString());
				
				// 设置错误回调
				Glfw.glfwSetErrorCallback(function(error_code:int, description:String):void
				{
					trace("GLFW错误:", error_code, description);
				});
				
				// 创建启动提示
				createStartupUI();
				
				//ANEGLFW.getInstance().debug = true;
				stage.addEventListener(MouseEvent.CLICK, startDemo);
			}
			else
			{
				trace("ANEGLFW扩展不支持");
			}
		
			// FPS显示已移除
		}
		
		/**
		 * 创建启动界面
		 */
		private function createStartupUI():void
		{
			_note = new TextField();
			_note.defaultTextFormat = new TextFormat(null, 16, 0xffffff);
			_note.text = "点击开始UI框架演示";
			_note.x = 250;
			_note.y = 50;
			_note.width = 300;
			_note.height = 30;
			addChild(_note);
			
			_statusText = new TextField();
			_statusText.defaultTextFormat = new TextFormat(null, 12, 0x00ff00);
			_statusText.text = "准备就绪...";
			_statusText.x = 250;
			_statusText.y = 80;
			_statusText.width = 400;
			_statusText.height = 20;
			addChild(_statusText);
		}
		
		/**
		 * 窗口大小调整事件处理
		 * @param e 事件对象
		 */
		private function stageResize(e:Event):void
		{
			if (isAIRWindow && windowIntPtr)
			{
				
				Glfw.glfwSetWindowPos(windowIntPtr, 0, 0);
				Glfw.glfwSetWindowSize(windowIntPtr, stage.stageWidth * Screen.mainScreen.contentsScaleFactor, stage.stageHeight * Screen.mainScreen.contentsScaleFactor);
				
			}
		}
		
		/**
		 * 开始演示
		 * @param e 鼠标事件
		 */
		private function startDemo(e:MouseEvent):void
		{
			removeChild(_note);
			stage.removeEventListener(MouseEvent.CLICK, startDemo);
			
			_statusText.text = "正在初始化GLFW...";
			
			// 初始化GLFW
			initializeGLFW();
		}
		
		/**
		 * 初始化GLFW
		 */
		private function initializeGLFW():void
		{
			Glfw.glfwInit();
			
			// 设置OpenGL版本和配置
			
			var t1:uint = getTimer();
			with (Glfw)
			{
				glfwWindowHint(Glfw.GLFW_SAMPLES, 4);
				glfwWindowHint(Glfw.GLFW_CONTEXT_VERSION_MAJOR, 3);
				glfwWindowHint(Glfw.GLFW_CONTEXT_VERSION_MINOR, 3);
				glfwWindowHint(Glfw.GLFW_OPENGL_PROFILE, Glfw.GLFW_OPENGL_CORE_PROFILE);
				glfwWindowHint(Glfw.GLFW_OPENGL_FORWARD_COMPAT, 1);
				
				// 绑定到AIR窗口
				if (isAIRWindow)
				{
					glfwWindowHint(Glfw.GLFW_DECORATED, 0);
					glfwWindowHint(Glfw.GLFW_FOCUSED, 0);
					glfwWindowHint(Glfw.GLFW_RESIZABLE, 0);
					glfwWindowHint(Glfw.GLFW_VISIBLE, 0);
				}
			}
			trace(getTimer() - t1, "sssss");
			
			glWidth = stage.stageWidth * Screen.mainScreen.contentsScaleFactor;
			glHeight = stage.stageHeight * Screen.mainScreen.contentsScaleFactor;
			// 创建窗口
			windowIntPtr = Glfw.glfwCreateWindow(glWidth, glHeight, "UI框架测试");
			trace("窗口指针:", windowIntPtr);
			
			if (!windowIntPtr)
			{
				_statusText.text = "创建GLFW窗口失败";
				return;
			}
			
			// 绑定到AIR原生窗口
			if (isAIRWindow)
			{
				var hwnd:int = Glfw.glfwGetWin32Window(windowIntPtr);
				if (hwnd)
				{
					ANEGLFW.getInstance().openGLToNativeWindow(hwnd, stage.nativeWindow);
					
					Glfw.glfwSetWindowPos(windowIntPtr, 0, 0);
				}
			}
			
			// 设置OpenGL上下文
			Glfw.glfwMakeContextCurrent(windowIntPtr);
			
			// 设置回调函数
			setupCallbacks();
			
			// 加载OpenGL函数
			if (!Gl.gladLoadGLLoader())
			{
				_statusText.text = "加载OpenGL函数失败";
				return;
			}
			
			_statusText.text = "正在初始化UI框架...";
			
			// 初始化UI框架
			initializeUIFramework();
		}
		
		/**
		 * 设置GLFW回调函数
		 */
		private function setupCallbacks():void
		{
			// 窗口大小回调
			Glfw.glfwSetWindowSizeCallback(windowIntPtr, function(wIntPtr:Number, width:int, height:int):void
			{
				glWidth = width;
				glHeight = height;
				Gl.glViewport(0, 0, width, height);
				
				fpsMonitor.x = width - fpsMonitor.width;
				
				//更新UI管理器视口
				if (_uiManager)
				{
					_uiManager.setViewport(width, height);
				}
				
				// 更新背景图片尺寸
				if (_backgroundImage)
				{
					_backgroundImage.width = width;
					_backgroundImage.height = height;
				}
			});
			
			// 鼠标位置回调
			Glfw.glfwSetCursorPosCallback(windowIntPtr, function(wIntPtr:Number, x:Number, y:Number):void
			{
				if (_uiManager)
				{
					_uiManager.handleMouseMove(x, y);
				}
			});
			
			// 鼠标按钮回调
			Glfw.glfwSetMouseButtonCallback(windowIntPtr, function(wIntPtr:Number, button:int, action:int, mods:int):void
			{
				if (_uiManager)
				{
					var mousePos:Point = Glfw.glfwGetCursorPos(windowIntPtr);
					
					if (action == Glfw.GLFW_PRESS)
					{
						_uiManager.handleMouseDown(mousePos.x, mousePos.y);
					}
					else if (action == Glfw.GLFW_RELEASE)
					{
						_uiManager.handleMouseUp(mousePos.x, mousePos.y);
					}
				}
			});
		}
		
		/**
		 * 初始化UI框架
		 */
		private function initializeUIFramework():void
		{
			// 获取UI管理器实例
			_uiManager = UIManager.getInstance();
			_uiManager.setViewport(glWidth, glHeight);
			
			// 设置OpenGL状态
			Gl.glEnable(Gl.GL_BLEND);
			Gl.glBlendFunc(Gl.GL_SRC_ALPHA, Gl.GL_ONE_MINUS_SRC_ALPHA);
			Gl.glClearColor(0.1, 0.1, 0.1, 1.0);
			
			_statusText.text = "正在创建UI组件...";
			
			// 初始化背景图片URL列表
			initializeBackgroundUrls();
			
			// 创建背景组件
			createBackgroundImage();
			
			// 创建测试组件
			createTestComponents();
			
			// 创建TextRenderer测试组件
			createTextRendererTests();
			
			_statusText.text = "正在运行测试用例...";
			
			// 运行测试用例
			//runTests();
			
			// 开始渲染循环
			addEventListener(Event.ENTER_FRAME, renderFrame);
			
			_statusText.text = "UI框架演示运行中 - 尝试点击按钮!";
		}
		
		/**
		 * 创建测试组件
		 */
		private function createTestComponents():void
		{
			// 创建FPS监控组件
			fpsMonitor = new FpsMonitor(glWidth - 90, 0);
			_uiManager.addComponent(fpsMonitor);
			
			// 创建按钮1 - 普通按钮
			_testButton1 = new Button(50, 50, 120, 40, "点击我!");
			_testButton1.addEventListener(UIEvent.CLICK, onButton1Click);
			_uiManager.addComponent(_testButton1);
			
			// 创建按钮2 - 自定义颜色
			_testButton2 = new Button(200, 50, 120, 40, "自定义按钮");
			_testButton2.setColors(new <Number>[0.2, 0.6, 0.2, 1.0], // 绿色正常状态
			new <Number>[0.3, 0.8, 0.3, 1.0], // 亮绿色悬停状态
			new <Number>[0.1, 0.4, 0.1, 1.0], // 深绿色按下状态
			new <Number>[0.1, 0.3, 0.1, 0.5]  // 半透明禁用状态
			);
			_testButton2.addEventListener(UIEvent.CLICK, onButton2Click);
			_uiManager.addComponent(_testButton2);
			
			// 创建按钮3 - 可禁用按钮
			_testButton3 = new Button(350, 50, 120, 40, "切换状态");
			_testButton3.addEventListener(UIEvent.CLICK, onButton3Click);
			_uiManager.addComponent(_testButton3);
			
			// 创建图片组件并生成测试图片
			_testImage = new Image(50, 120, 200, 150);
			_testImage.addEventListener(UIEvent.CLICK, onImageClick);
			_testImage.addEventListener(UIEvent.ERROR, onImageError);
			_testImage.addEventListener(UIEvent.COMPLETE, onImageLoaded);
			_uiManager.addComponent(_testImage);
			
			// 生成测试图片数据
			createTestImage();
		
		}
		
		/**
		 * 创建TextRenderer测试组件
		 */
		private function createTextRendererTests():void
		{
			// 创建标题文本
			var titleText:TextRenderer = new TextRenderer(300, 120, 250, 35);
			titleText.setText("TextRenderer测试", 20, 0xFF0000, "微软雅黑");
			_uiManager.addComponent(titleText);
			
			// 创建描述文本
			var descText:TextRenderer = new TextRenderer(300, 170, 300, 25);
			descText.setText("独立的文本渲染组件", 14, 0x0000FF, "微软雅黑");
			_uiManager.addComponent(descText);
			
			// 创建小字体文本
			var smallText:TextRenderer = new TextRenderer(300, 210, 200, 20);
			smallText.setText("小字体 (12px)", 12, 0x666666, "微软雅黑");
			_uiManager.addComponent(smallText);
			
			// 创建大字体文本
			var largeText:TextRenderer = new TextRenderer(50, 300, 350, 40);
			largeText.setText("大字体标题 (24px)", 24, 0x800080, "微软雅黑");
			_uiManager.addComponent(largeText);
			
			// 创建多色文本示例
			var colorText1:TextRenderer = new TextRenderer(50, 360, 150, 25);
			colorText1.setText("红色文本", 16, 0xFF0000, "微软雅黑");
			_uiManager.addComponent(colorText1);
			
			var colorText2:TextRenderer = new TextRenderer(220, 360, 150, 25);
			colorText2.setText("绿色文本", 16, 0x00FF00, "微软雅黑");
			_uiManager.addComponent(colorText2);
			
			var colorText3:TextRenderer = new TextRenderer(390, 360, 150, 25);
			colorText3.setText("蓝色文本", 16, 0x0000FF, "微软雅黑");
			_uiManager.addComponent(colorText3);
		}
		
		/**
		 * 按钮1点击事件处理
		 * @param event 事件对象
		 */
		private function onButton1Click(event:UIEvent):void
		{
			trace("按钮1被点击!");
			_statusText.text = "按钮1被点击! 坐标: (" + event.mouseX + ", " + event.mouseY + ")";
		}
		
		/**
		 * 按钮2点击事件处理
		 * @param event 事件对象
		 */
		private function onButton2Click(event:UIEvent):void
		{
			trace("自定义按钮被点击!");
			_statusText.text = "自定义按钮被点击! 这是一个绿色主题的按钮";
		}
		
		/**
		 * 按钮3点击事件处理
		 * @param event 事件对象
		 */
		private function onButton3Click(event:UIEvent):void
		{
			// 切换按钮2的启用状态
			_testButton2.enabled = !_testButton2.enabled;
			trace("切换按钮2状态为:", _testButton2.enabled ? "启用" : "禁用");
			_statusText.text = "按钮2现在" + (_testButton2.enabled ? "启用" : "禁用");
		}
		
		/**
		 * 图片点击事件处理
		 * @param event 事件对象
		 */
		private function onImageClick(event:UIEvent):void
		{
			trace("图片被点击!");
			_statusText.text = "图片组件被点击! (当前没有加载实际图片)";
		}
		
		/**
		 * 创建测试图片
		 */
		private function createTestImage():void
		{
			// 创建一个200x150的测试图片
			var testBitmap:BitmapData = new BitmapData(200, 150, true, 0x00000000);
			
			// 绘制渐变背景
			for (var y:int = 0; y < 150; y++)
			{
				for (var x:int = 0; x < 200; x++)
				{
					var r:int = Math.floor((x / 200) * 255);
					var g:int = Math.floor((y / 150) * 255);
					var b:int = Math.floor(((x + y) / 350) * 255);
					var color:uint = 0xFF000000 | (r << 16) | (g << 8) | b;
					testBitmap.setPixel32(x, y, color);
				}
			}
			
			// 绘制一些装饰性图形
			// 绘制圆圈
			for (var angle:Number = 0; angle < Math.PI * 2; angle += 0.1)
			{
				var cx:int = 100 + Math.cos(angle) * 30;
				var cy:int = 75 + Math.sin(angle) * 20;
				if (cx >= 0 && cx < 200 && cy >= 0 && cy < 150)
				{
					testBitmap.setPixel32(cx, cy, 0xFFFFFFFF); // 白色圆圈
				}
			}
			
			var bb:Bitmap = new imgBitmap();
			// 直接设置图片组件的位图数据
			_testImage.loadFromBitmapData(bb.bitmapData);
		}
		
		/**
		 * 图片加载完成事件处理
		 * @param event 事件对象
		 */
		private function onImageLoaded(event:UIEvent):void
		{
			trace("图片加载完成!");
			_statusText.text = "图片加载完成! 尺寸: " + _testImage.textureWidth + "x" + _testImage.textureHeight;
		}
		
		/**
		 * 图片错误事件处理
		 * @param event 事件对象
		 */
		private function onImageError(event:UIEvent):void
		{
			trace("图片加载错误:", event.data);
			_statusText.text = "图片加载失败: " + event.data;
		}
		
		/**
		 * 运行测试用例
		 */
		private function runTests():void
		{
			_testCase = new UITestCase();
			_testCase.addEventListener(UITestCase.TEST_COMPLETE, onTestComplete);
			_testCase.addEventListener(UITestCase.TEST_FAILED, onTestFailed);
			
			// 延迟运行测试，让UI组件先初始化
			setTimeout(function():void
			{
				_testCase.runAllTests();
			}, 1000);
		}
		
		/**
		 * 测试完成事件处理
		 * @param event 事件对象
		 */
		private function onTestComplete(event:UIEvent):void
		{
			trace("所有测试通过!");
		}
		
		/**
		 * 测试失败事件处理
		 * @param event 事件对象
		 */
		private function onTestFailed(event:UIEvent):void
		{
			trace("测试失败:", event.data);
		}
		
		/**
		 * 渲染帧
		 * @param e 事件对象
		 */
		private function renderFrame(e:Event = null):void
		{
			if (!Glfw.glfwWindowShouldClose(windowIntPtr))
			{
				// 清除缓冲区
				Gl.glClear(Gl.GL_COLOR_BUFFER_BIT | Gl.GL_DEPTH_BUFFER_BIT);
				
				// 渲染UI组件
				if (_uiManager)
				{
					_uiManager.render();
				}
				
				with (Glfw)
				{
					// 交换缓冲区
					glfwSwapBuffers(windowIntPtr);
					
					// 处理事件
					glfwPollEvents();
				}
				
			}
		}
		
		/**
		 * 关闭应用程序
		 * @param e 事件对象
		 */
		private function closeApp(e:Event):void
		{
			try
			{
				
				_backgroundTimer.removeEventListener(TimerEvent.TIMER, onBackgroundTimer);
				_backgroundTimer.stop();
			
			
				// 移除事件监听器
				removeEventListener(Event.ENTER_FRAME, renderFrame);
				
				// 清理UI管理器
				//if (_uiManager)
				//{
					//_uiManager.dispose();
					//_uiManager = null;
				//}
				
				// 清理GLFW资源
				if (windowIntPtr)
				{
					Glfw.glfwSetWindowShouldClose(windowIntPtr, true);
					Glfw.glfwDestroyWindow(windowIntPtr);
				}
				//
				// 终止GLFW
				Glfw.glfwTerminate();
				
			}
			catch (error:Error)
			{
				trace("关闭应用程序时发生错误:", error.message);
				trace("错误堆栈:", error.getStackTrace());
			}
		}
		
		/**
		 * 初始化背景图片URL列表
		 */
		private function initializeBackgroundUrls():void
		{
			_backgroundUrls = new Vector.<String>();
			// 原始URL作为备选
			_backgroundUrls.push("https://cdn.edstatic.com/202608280150/abfd01e387d06ab4f2b52e5d40f44ab9/2024/10/15/de4f45da18553ef731d69e9ae14908bc69b46089.png");
			_backgroundUrls.push("https://cdn.edstatic.com/202608280150/41758bf9ec0c12e3bd0a6425a6141179/2024/12/10/dcbffc79daed224b184a3b09996aff7ef14e6fd6.jpg");
			_backgroundUrls.push("https://cdn.edstatic.com/202608280150/196347ae36ce69ca1c04b43493ddccee/2025/01/22/8c2f692e3091ff086eca8804b22539fa3d466743.jpg");
		}
		
		/**
		 * 创建背景图片组件
		 */
		private function createBackgroundImage():void
		{
			// 创建全屏背景图片组件
			_backgroundImage = new Image(0, 0, glWidth, glHeight);
			_backgroundImage.alpha = 1.0; // 确保背景图片完全不透明
			_backgroundImage.scaleMode = Image.SCALE_MODE_FILL;
			_backgroundImage.addEventListener(UIEvent.COMPLETE, onBackgroundImageLoaded);
			_backgroundImage.addEventListener(UIEvent.ERROR, onBackgroundImageError);
			
			trace("创建背景图片组件: 位置(0, 0) 尺寸(" + glWidth + ", " + glHeight + ")");
			trace("当前UI管理器组件数量: " + _uiManager.getComponentCount());
			
			_uiManager.addBackgroundComponent(_backgroundImage); // 使用专门的方法添加到最底层
			
			trace("添加背景图片后UI管理器组件数量: " + _uiManager.getComponentCount());
			
			// 加载第一张背景图片
			trace("开始加载背景图片: " + _backgroundUrls[_currentBackgroundIndex]);
			_backgroundImage.loadImage(_backgroundUrls[_currentBackgroundIndex]);
			
			// 同时创建一个本地测试背景作为备选
			setTimeout(function():void
			{
				if (!_backgroundImage.isLoaded)
				{
					trace("网络图片加载超时，使用本地测试背景");
					createTestBackground();
				}
			}, 3000); // 3秒超时
			
			// 创建定时器，每5秒切换一次背景
			_backgroundTimer = new Timer(5000);
			_backgroundTimer.addEventListener(TimerEvent.TIMER, onBackgroundTimer);
			_backgroundTimer.start();
		}
		
		/**
		 * 背景图片加载完成事件处理
		 * @param event 事件对象
		 */
		private function onBackgroundImageLoaded(event:UIEvent):void
		{
			trace("背景图片加载完成: " + _backgroundUrls[_currentBackgroundIndex]);
			trace("背景图片尺寸: " + _backgroundImage.textureWidth + "x" + _backgroundImage.textureHeight);
			trace("背景图片位置: (" + _backgroundImage.x + ", " + _backgroundImage.y + ") 尺寸: " + _backgroundImage.width + "x" + _backgroundImage.height);
			trace("背景图片是否已加载: " + _backgroundImage.isLoaded);
		}
		
		/**
		 * 背景图片加载错误事件处理
		 * @param event 事件对象
		 */
		private function onBackgroundImageError(event:UIEvent):void
		{
			trace("背景图片加载失败: " + event.data);
			trace("尝试创建本地测试背景图片");
			
			// 如果网络图片加载失败，创建一个本地测试背景
			createTestBackground();
		}
		
		/**
		 * 背景定时器事件处理
		 * @param event 定时器事件
		 */
		private function onBackgroundTimer(event:TimerEvent):void
		{
			switchToNextBackground();
		}
		
		/**
		 * 切换到下一张背景图片
		 */
		private function switchToNextBackground():void
		{
			_currentBackgroundIndex = (_currentBackgroundIndex + 1) % _backgroundUrls.length;
			_backgroundImage.loadImage(_backgroundUrls[_currentBackgroundIndex]);
			trace("切换背景图片: " + _backgroundUrls[_currentBackgroundIndex]);
		}
		
		/**
		 * 创建测试背景图片
		 */
		private function createTestBackground():void
		{
			// 创建一个渐变背景图片
			var bgBitmap:BitmapData = new BitmapData(glWidth, glHeight, false, 0x000000);
			
			// 创建彩色渐变背景
			for (var y:int = 0; y < glHeight; y++)
			{
				for (var x:int = 0; x < glWidth; x++)
				{
					var r:int = Math.floor((x / glWidth) * 255);
					var g:int = Math.floor((y / glHeight) * 255);
					var b:int = Math.floor(((x + y) / (glWidth + glHeight)) * 255);
					var color:uint = (r << 16) | (g << 8) | b;
					bgBitmap.setPixel(x, y, color);
				}
			}
			
			// 添加一些装饰图案
			for (var i:int = 0; i < 50; i++)
			{
				var cx:int = Math.random() * glWidth;
				var cy:int = Math.random() * glHeight;
				var radius:int = 10 + Math.random() * 20;
				
				for (var angle:Number = 0; angle < Math.PI * 2; angle += 0.1)
				{
					var px:int = cx + Math.cos(angle) * radius;
					var py:int = cy + Math.sin(angle) * radius;
					if (px >= 0 && px < glWidth && py >= 0 && py < glHeight)
					{
						bgBitmap.setPixel(px, py, 0xFFFFFF); // 白色圆圈
					}
				}
			}
			
			trace("创建本地测试背景图片，尺寸: " + glWidth + "x" + glHeight);
			_backgroundImage.loadFromBitmapData(bgBitmap);
		}
		
		/**
		 * 简单的setTimeout实现
		 * @param callback 回调函数
		 * @param delay 延迟时间（毫秒）
		 */
		private function setTimeout(callback:Function, delay:Number):void
		{
			var timer:flash.utils.Timer = new flash.utils.Timer(delay, 1);
			
			// 添加到活动定时器列表中进行管理
			_activeTimers.push(timer);
			
			timer.addEventListener(flash.events.TimerEvent.TIMER_COMPLETE, function(event:flash.events.TimerEvent):void
			{
				try
				{
					callback();
				}
				catch (error:Error)
				{
					trace("setTimeout回调执行错误:", error.message);
				}
				finally
				{
					// 清理定时器
					timer.removeEventListener(flash.events.TimerEvent.TIMER_COMPLETE, arguments.callee);
					var index:int = _activeTimers.indexOf(timer);
					if (index >= 0)
					{
						_activeTimers.splice(index, 1);
					}
				}
			});
			timer.start();
		}
	}
}
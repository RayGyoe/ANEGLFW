package ui.components
{
	import flash.display.Bitmap;
	import flash.utils.Endian;
	import ui.core.UIComponent;
	import ui.events.UIEvent;
	import agl.shader.Shader;
	import com.vsdevelop.air.extension.glfw.Gl;
	import agl.utils.Matrix4;
	import flash.display.BitmapData;
	import flash.display.Loader;
	import flash.net.URLRequest;
	import flash.events.Event;
	import flash.events.IOErrorEvent;
	import flash.geom.Matrix3D;
	import flash.utils.ByteArray;

	/**
	 * 图片组件类
	 * 提供图片显示功能，支持纹理加载、缩放模式和事件处理
	 * @author Generated by AI Assistant
	 */
	public class Image extends UIComponent
	{
		// 缩放模式枚举
		public static const SCALE_MODE_STRETCH:String = "stretch";     // 拉伸填充
		public static const SCALE_MODE_FIT:String = "fit";             // 等比缩放适应
		public static const SCALE_MODE_FILL:String = "fill";           // 等比缩放填充
		public static const SCALE_MODE_NONE:String = "none";           // 原始大小
		
		// 图片属性
		private var _source:String = "";
		private var _scaleMode:String = SCALE_MODE_STRETCH;
		private var _smooth:Boolean = true;
		
		// 纹理相关
		private var _texture:uint = 0;
		private var _textureWidth:Number = 0;
		private var _textureHeight:Number = 0;
		private var _isLoaded:Boolean = false;
		
		// 加载相关
		private var _loader:Loader;
		private var _bitmapData:BitmapData;
		
		// 着色器资源
		[Embed(source="../../assets/ui/ui_vertex.glsl", mimeType="application/octet-stream")]
		private var VertexShaderSource:Class;
		
		[Embed(source="../../assets/ui/ui_fragment.glsl", mimeType="application/octet-stream")]
		private var FragmentShaderSource:Class;
		
		// 渲染相关
		private var _modelMatrix:Matrix4;
		private var _textureVertices:Vector.<Number>;
		
		/**
		 * 构造函数
		 * @param x X坐标
		 * @param y Y坐标
		 * @param width 宽度
		 * @param height 高度
		 * @param source 图片源路径
		 */
		public function Image(x:Number = 0, y:Number = 0, width:Number = 100, height:Number = 100, source:String = "")
		{
			super(x, y, width, height);
			_source = source;
			
			initializeImage();
			
			if (_source && _source.length > 0)
			{
				loadImage(_source);
			}
		}
		
		/**
		 * 初始化图片组件
		 */
		private function initializeImage():void
		{
			// 创建着色器
			var vs:String = new VertexShaderSource();
			var fs:String = new FragmentShaderSource();
			_shader = new Shader(vs, fs);
			
			// 创建模型矩阵
			_modelMatrix = new Matrix4();
			
			// 生成纹理对象
			with (Gl)
			{
				_texture = glGenTextures(uint(1));
			}
		}
		
		/**
		 * 加载图片
		 * @param url 图片URL
		 */
		public function loadImage(url:String):void
		{
			_source = url;
			_isLoaded = false;
			
			// 清理之前的加载器
			if (_loader)
			{
				_loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, onImageLoaded);
				_loader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR, onImageError);
				_loader.contentLoaderInfo.removeEventListener(IOErrorEvent.VERIFY_ERROR, onVerifyError);
				_loader = null;
			}
			
			// 创建新的加载器
			_loader = new Loader();
			_loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onImageLoaded);
			_loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onImageError);
			_loader.contentLoaderInfo.addEventListener(IOErrorEvent.VERIFY_ERROR, onVerifyError);
			
			try
			{
				_loader.load(new URLRequest(url));
			}
			catch (error:Error)
			{
				trace("Error loading image: " + error.message);
					dispatchEvent(new UIEvent(UIEvent.ERROR, false, false, NaN, NaN, error.message));
			}
		}
		
		private function onVerifyError(e:IOErrorEvent):void 
		{
			trace(e);
		}
		
		/**
		 * 从BitmapData直接加载图片
		 * @param bitmapData 位图数据
		 */
		public function loadFromBitmapData(bitmapData:BitmapData):void
		{
			if (!bitmapData)
			{
				trace("Error: BitmapData is null");
				dispatchEvent(new UIEvent(UIEvent.ERROR, false, false, NaN, NaN, "BitmapData is null"));
				return;
			}
			
			try
			{
				// 清理之前的位图数据
				if (_bitmapData)
				{
					_bitmapData.dispose();
				}
				
				// 设置新的位图数据
				_bitmapData = bitmapData.clone();
				_textureWidth = _bitmapData.width;
				_textureHeight = _bitmapData.height;
				_source = "[Generated]";
				
				// 创建OpenGL纹理
				createTexture();
				
				// 更新顶点数据
				updateTextureVertices();
				
				_isLoaded = true;
				_needsRedraw = true;
				
				// 派发加载完成事件
				dispatchEvent(new UIEvent(UIEvent.COMPLETE));
			}
			catch (error:Error)
			{
				trace("Error loading from BitmapData: " + error.message);
				dispatchEvent(new UIEvent(UIEvent.ERROR, false, false, NaN, NaN, error.message));
			}
		}
		
		/**
		 * 图片加载完成事件处理
		 * @param event 事件对象
		 */
		private function onImageLoaded(event:Event):void
		{
			try
			{
				// 获取位图数据
				_bitmapData = (_loader.content as Bitmap).bitmapData;
				_textureWidth = _bitmapData.width;
				_textureHeight = _bitmapData.height;
				
				// 创建OpenGL纹理
				createTexture();
				
				// 更新顶点数据
				updateTextureVertices();
				
				_isLoaded = true;
				_needsRedraw = true;
				
				// 派发加载完成事件
				dispatchEvent(new UIEvent(UIEvent.COMPLETE));
			}
			catch (error:Error)
			{
				trace("Error processing loaded image: " + error.message);
				dispatchEvent(new UIEvent(UIEvent.ERROR, false, false, NaN, NaN, error.message));
			}
		}
		
		/**
		 * 图片加载错误事件处理
		 * @param event 事件对象
		 */
		private function onImageError(event:IOErrorEvent):void
		{
			trace("Error loading image: " + event.text);
			dispatchEvent(new UIEvent(UIEvent.ERROR, false, false, NaN, NaN, String(event.text)));
		}
		
		/**
		 * 创建OpenGL纹理
		 */
		private function createTexture():void
		{
			if (!_bitmapData) return;
			
			with (Gl)
			{
				// 绑定纹理
				glBindTexture(GL_TEXTURE_2D, _texture);
				
				// 设置纹理参数
				if (_smooth)
				{
					glTexParameteri(GL_TEXTURE_2D, uint(GL_TEXTURE_MIN_FILTER), uint(GL_LINEAR));
					glTexParameteri(GL_TEXTURE_2D, uint(GL_TEXTURE_MAG_FILTER), uint(GL_LINEAR));
				}
				else
				{
					glTexParameteri(GL_TEXTURE_2D, uint(GL_TEXTURE_MIN_FILTER), uint(GL_NEAREST));
					glTexParameteri(GL_TEXTURE_2D, uint(GL_TEXTURE_MAG_FILTER), uint(GL_NEAREST));
				}
				
				glTexParameteri(GL_TEXTURE_2D, uint(GL_TEXTURE_WRAP_S), uint(GL_CLAMP_TO_EDGE));
				glTexParameteri(GL_TEXTURE_2D, uint(GL_TEXTURE_WRAP_T), uint(GL_CLAMP_TO_EDGE));
			
			
			
			
			// 上传纹理数据
			var pixelBytes:ByteArray = new ByteArray();
			pixelBytes.endian = Endian.LITTLE_ENDIAN;
			
			_bitmapData.copyPixelsToByteArray(_bitmapData.rect, pixelBytes);
			
			
			//var pixels:Vector.<uint> = _bitmapData.getVector(_bitmapData.rect);
			//for (var i:int = 0; i < pixels.length; i++)
			//{
				//var pixel:uint = pixels[i];
				//pixelBytes.writeByte((pixel >> 16) & 0xFF); // R
				//pixelBytes.writeByte((pixel >> 8) & 0xFF);  // G
				//pixelBytes.writeByte(pixel & 0xFF);         // B
				//pixelBytes.writeByte((pixel >> 24) & 0xFF); // A
			//}
				
				pixelBytes.position = 0;
				
				glTexImage2D(GL_TEXTURE_2D, uint(0), GL_RGBA, uint(_textureWidth), uint(_textureHeight),uint(0), GL_BGRA, GL_UNSIGNED_BYTE, pixelBytes);
				//glTexImage2D(GL_TEXTURE_2D, uint(0), GL_BGRA, uint(_textureWidth), uint(_textureHeight),uint(0), GL_BGRA, GL_UNSIGNED_BYTE, pixelBytes);
				
				// 解绑纹理
				glBindTexture(GL_TEXTURE_2D, 0);
			}
		}
		
		/**
		 * 更新纹理顶点数据
		 */
		private function updateTextureVertices():void
		{
			if (!_isLoaded) return;
			
			var renderX:Number = _x;
			var renderY:Number = _y;
			var renderWidth:Number = _width;
			var renderHeight:Number = _height;
			
			// 根据缩放模式计算渲染尺寸和位置
			switch (_scaleMode)
			{
				case SCALE_MODE_FIT:
					var scaleX:Number = _width / _textureWidth;
					var scaleY:Number = _height / _textureHeight;
					var scale:Number = Math.min(scaleX, scaleY);
					renderWidth = _textureWidth * scale;
					renderHeight = _textureHeight * scale;
					renderX = _x + (_width - renderWidth) * 0.5;
					renderY = _y + (_height - renderHeight) * 0.5;
					break;
					
				case SCALE_MODE_FILL:
					scaleX = _width / _textureWidth;
					scaleY = _height / _textureHeight;
					scale = Math.max(scaleX, scaleY);
					renderWidth = _textureWidth * scale;
					renderHeight = _textureHeight * scale;
					renderX = _x + (_width - renderWidth) * 0.5;
					renderY = _y + (_height - renderHeight) * 0.5;
					break;
					
				case SCALE_MODE_NONE:
					renderWidth = _textureWidth;
					renderHeight = _textureHeight;
					renderX = _x + (_width - renderWidth) * 0.5;
					renderY = _y + (_height - renderHeight) * 0.5;
					break;
					
				default: // SCALE_MODE_STRETCH
					// 使用默认值
					break;
			}
			
			// 创建顶点数据（位置 + 纹理坐标）
			_textureVertices = new <Number>[
				// 第一个三角形
				renderX, renderY, 0.0, 1.0,                    // 左上
				renderX + renderWidth, renderY, 1.0, 1.0,      // 右上
				renderX, renderY + renderHeight, 0.0, 0.0,     // 左下
				
				// 第二个三角形
				renderX + renderWidth, renderY, 1.0, 1.0,      // 右上
				renderX + renderWidth, renderY + renderHeight, 1.0, 0.0, // 右下
				renderX, renderY + renderHeight, 0.0, 0.0      // 左下
			];
			
			// 更新VBO
			updateVertexData(_textureVertices);
		}
		
		/**
		 * 重写位置和尺寸更新方法
		 */
		protected override function updateVertexData(vertices:Vector.<Number> = null):void
		{
			if (_isLoaded && _textureVertices)
			{
				// 更新纹理顶点数据
				super.updateVertexData(_textureVertices);
			}
			else
			{
				// 更新自定义顶点数据
				super.updateVertexData(vertices);
			}
		}
		
		/**
		 * 重写渲染方法
		 */
		protected override function doRender():void
		{
			if (!_shader || !_isLoaded) return;
			
			// 使用着色器程序
			_shader.useProgram();
			
			// 设置模型矩阵
			_modelMatrix.identity();
			_shader.setMatrix4fv("uModel", _modelMatrix);
			
			// 设置投影矩阵
			var uiManager:ui.core.UIManager = ui.core.UIManager.getInstance();
			_shader.setMatrix4fv("uProjection", uiManager.projectionMatrix);
			
			// 设置着色器参数和绘制图片
			with (Gl)
			{
				// 设置颜色（白色，不影响纹理）
				glUniform4f(glGetUniformLocation(_shader.program, "uColor"), 1.0, 1.0, 1.0, 1.0);
				
				// 设置透明度
				glUniform1f(glGetUniformLocation(_shader.program, "uAlpha"), _alpha);
				
				// 设置使用纹理
				glUniform1i(glGetUniformLocation(_shader.program, "uUseTexture"), 1);
				
				// 绑定纹理
				glActiveTexture(GL_TEXTURE0);
				glBindTexture(GL_TEXTURE_2D, uint(_texture));
				glUniform1i(glGetUniformLocation(_shader.program, "uTexture"), 0);
				
				// 绘制图片
				glBindVertexArray(uint(_VAO));
				glDrawArrays(GL_TRIANGLES, uint(0), uint(6));
				glBindVertexArray(uint(0));
				
				// 解绑纹理
				glBindTexture(GL_TEXTURE_2D, uint(0));
			}
		}
		
		/**
		 * 重写dispose方法
		 */
		public override function dispose():void
		{
			// 清理加载器
			if (_loader)
			{
				_loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, onImageLoaded);
				_loader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR, onImageError);
				_loader.contentLoaderInfo.removeEventListener(IOErrorEvent.VERIFY_ERROR, onVerifyError);
				_loader = null;
			}
			
			// 清理位图数据
			if (_bitmapData)
			{
				_bitmapData.dispose();
				_bitmapData = null;
			}
			
			// 删除纹理
			if (_texture > 0)
			{
				var textures:Vector.<uint> = new Vector.<uint>();
				textures.push(_texture);
				with (Gl)
				{
					glDeleteTextures(uint(1), textures);
				}
				_texture = 0;
			}
			
			super.dispose();
		}
		
		// 属性访问器
		public function get source():String { return _source; }
		public function set source(value:String):void
		{
			if (_source != value && value && value.length > 0)
			{
				loadImage(value);
			}
		}
		
		public function get scaleMode():String { return _scaleMode; }
		public function set scaleMode(value:String):void
		{
			if (_scaleMode != value)
			{
				_scaleMode = value;
				updateTextureVertices();
				_needsRedraw = true;
			}
		}
		
		public function get smooth():Boolean { return _smooth; }
		public function set smooth(value:Boolean):void
		{
			if (_smooth != value)
			{
				_smooth = value;
				if (_isLoaded)
				{
					createTexture(); // 重新创建纹理以应用新的过滤设置
					_needsRedraw = true;
				}
			}
		}
		
		public function get isLoaded():Boolean { return _isLoaded; }
		public function get textureWidth():Number { return _textureWidth; }
		public function get textureHeight():Number { return _textureHeight; }
	}
}
package ui.state
{
	import flash.utils.getTimer;
	import ui.core.UIComponent;
	import ui.text.TextRenderer;
	import agl.shader.Shader;
	import com.vsdevelop.air.extension.glfw.Gl;
	import agl.utils.Matrix4;

	/**
	 * FPS监控组件
	 * 继承自UIComponent，提供实时帧率监控和显示功能
	 * 适配OpenGL渲染环境，显示当前FPS、平均FPS、最小FPS和最大FPS
	 * @author Generated by AI Assistant
	 */
	public class FpsMonitor extends UIComponent
	{
		// FPS计算相关
		private var _frameCount:int = 0;
		private var _lastTime:Number = 0;
		private var _currentFps:Number = 0;
		private var _averageFps:Number = 0;
		private var _minFps:Number = Number.MAX_VALUE;
		private var _maxFps:Number = 0;
		private var _totalFrames:int = 0;
		private var _startTime:Number = 0;
		
		// 更新频率控制
		private var _updateInterval:Number = 1000; // 1秒更新一次
		private var _lastUpdateTime:Number = 0;
		
		// 文本渲染器
		private var _textRenderer:TextRenderer;
		
		// 显示设置
		private var _showDetailed:Boolean = true;
		private var _fontSize:Number = 14;
		private var _fontColor:int = 0x00FF00; // 绿色
		private var _backgroundColor:Vector.<Number>;
		
		// 嵌入着色器源码
		[Embed(source="../../assets/ui/ui_vertex.glsl", mimeType="application/octet-stream")]
		private var VertexShaderSource:Class;
		
		[Embed(source="../../assets/ui/ui_fragment.glsl", mimeType="application/octet-stream")]
		private var FragmentShaderSource:Class;
		
		/**
		 * 构造函数
		 * @param x X坐标
		 * @param y Y坐标
		 * @param width 宽度
		 * @param height 高度
		 * @param showDetailed 是否显示详细信息（包括平均、最小、最大FPS）
		 */
		public function FpsMonitor(x:Number = 10, y:Number = 10, width:Number = 100, height:Number = 80, showDetailed:Boolean = true)
		{
			super(x, y, width, height);
			
			_showDetailed = showDetailed;
			_backgroundColor = new <Number>[0.0, 0.0, 0.0, 0.5]; // 半透明黑色背景
			
			// 初始化文本渲染器
			_textRenderer = new TextRenderer(x + 5, y + 5, width - 10, height - 10);
			
			// 初始化着色器
			initializeShader();
			
			// 初始化OpenGL资源
			initializeGL();
			
			// 初始化时间
			_startTime = getTimer();
			_lastTime = _startTime;
			_lastUpdateTime = _startTime;
			
			// 设置初始文本
			updateDisplayText();
		}
		
		/**
		 * 更新FPS计算
		 * 应该在每帧渲染时调用
		 */
		public function update():void
		{
			var currentTime:Number = getTimer();
			_frameCount++;
			_totalFrames++;
			
			// 检查是否需要更新FPS显示
			if (currentTime - _lastUpdateTime >= _updateInterval)
			{
				// 计算当前FPS
				var deltaTime:Number = currentTime - _lastUpdateTime;
				_currentFps = (_frameCount * 1000) / deltaTime;
				
				// 计算平均FPS
				var totalTime:Number = currentTime - _startTime;
				_averageFps = (_totalFrames * 1000) / totalTime;
				
				// 更新最小和最大FPS
				if (_currentFps < _minFps && _currentFps > 0)
				{
					_minFps = _currentFps;
				}
				if (_currentFps > _maxFps)
				{
					_maxFps = _currentFps;
				}
				
				// 更新显示文本
				updateDisplayText();
				
				// 重置计数器
				_frameCount = 0;
				_lastUpdateTime = currentTime;
			}
		}
		
		/**
		 * 更新显示文本
		 */
		private function updateDisplayText():void
		{
			var displayText:String;
			
			if (_showDetailed)
			{
				displayText = "FPS: " + _currentFps.toFixed(1) + "\n" +
							 "Avg: " + _averageFps.toFixed(1) + "\n" +
							 "Min: " + (_minFps == Number.MAX_VALUE ? "--" : _minFps.toFixed(1)) + "\n" +
							 "Max: " + _maxFps.toFixed(1);
			}
			else
			{
				displayText = "FPS: " + _currentFps.toFixed(1);
			}
			
			_textRenderer.setText(displayText, _fontSize, _fontColor, "Consolas");
		}
		
		/**
		 * 初始化着色器
		 */
		private function initializeShader():void
		{
			// 创建着色器
			var vs:String = new VertexShaderSource();
			var fs:String = new FragmentShaderSource();
			_shader = new Shader(vs, fs);
		}
		
		/**
		 * 重写updateVertices方法，让背景高度只有一行文字高度
		 */
		override protected function updateVertices():void
		{
			// 创建矩形顶点数据，背景高度只使用单行文字高度
			_vertices = new <Number>[
				// 位置 (x, y, z)     纹理坐标 (u, v)
				_x, _y, 0,         0, 0,
				_x + _width, _y, 0, 1.0, 0,
				_x + _width, _y + _height, 0, 1, 1,
				
				_x, _y, 0,         0, 0,
				_x + _width, _y + _height, 0, 1, 1,
				_x, _y + _height, 0, 0, 1
			];
			
			updateVertexData(_vertices);
		}
		
		/**
		 * 重写doRender方法实现FPS监控器的渲染
		 */
		override protected function doRender():void
		{
			// 更新FPS计算
			update();
			
			// 只有在初始化完成后才渲染背景
			if (_shader && _VAO > 0)
			{
				_shader.useProgram();
				
				// 设置模型矩阵（单位矩阵）
				var modelMatrix:Matrix4 = new Matrix4();
				_shader.setMatrix4fv("uModel", modelMatrix);
				
				// 设置投影矩阵（从UIManager获取）
				var uiManager:ui.core.UIManager = ui.core.UIManager.getInstance();
				_shader.setMatrix4fv("uProjection", uiManager.projectionMatrix);
				
				// 设置背景颜色
				with (Gl)
				{
					glUniform4f(glGetUniformLocation(_shader.program, "uColor"), 
							   _backgroundColor[0], _backgroundColor[1], _backgroundColor[2], _backgroundColor[3]);
					glUniform1f(glGetUniformLocation(_shader.program, "uAlpha"), alpha);
					glUniform1i(glGetUniformLocation(_shader.program, "uUseTexture"), 0);
					
					// 启用混合
					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
					
					// 绘制背景矩形
					glBindVertexArray(uint(_VAO));
					glDrawArrays(GL_TRIANGLES, uint(0), uint(6));
					glBindVertexArray(uint(0));
					
					// 禁用混合
					glDisable(GL_BLEND);
				}
			}
			
			// 渲染文本
			if (_textRenderer)
			{
				_textRenderer.render();
			}
		}
		
		/**
		 * 重置FPS统计
		 */
		public function reset():void
		{
			_frameCount = 0;
			_totalFrames = 0;
			_currentFps = 0;
			_averageFps = 0;
			_minFps = Number.MAX_VALUE;
			_maxFps = 0;
			_startTime = getTimer();
			_lastTime = _startTime;
			_lastUpdateTime = _startTime;
			
			updateDisplayText();
		}
		
		/**
		 * 设置更新间隔
		 * @param interval 更新间隔（毫秒）
		 */
		public function setUpdateInterval(interval:Number):void
		{
			_updateInterval = Math.max(100, interval); // 最小100ms
		}
		
		/**
		 * 设置字体大小
		 * @param size 字体大小
		 */
		public function setFontSize(size:Number):void
		{
			_fontSize = size;
			updateDisplayText();
		}
		
		/**
		 * 设置字体颜色
		 * @param color 字体颜色
		 */
		public function setFontColor(color:int):void
		{
			_fontColor = color;
			updateDisplayText();
		}
		
		/**
		 * 设置背景颜色
		 * @param color 背景颜色向量 [r, g, b, a]
		 */
		public function setBackgroundColor(color:Vector.<Number>):void
		{
			_backgroundColor = color;
		}
		
		/**
		 * 设置是否显示详细信息
		 * @param detailed 是否显示详细信息
		 */
		public function setShowDetailed(detailed:Boolean):void
		{
			_showDetailed = detailed;
			
			// 根据显示模式调整高度
			if (_showDetailed)
			{
				height = 80;
			}
			else
			{
				height = 25;
			}
			
			// 更新文本渲染器边界
			_textRenderer.setBounds(_x + 5, _y + 5, _width - 10, _height - 10);
			updateDisplayText();
		}
		
		/**
		 * 重写dispose方法以释放资源
		 */
		override public function dispose():void
		{
			if (_textRenderer)
			{
				_textRenderer.dispose();
				_textRenderer = null;
			}
			
			// 调用父类的dispose方法
			super.dispose();
		}
		
		// 属性访问器
		
		/**
		 * 获取当前FPS
		 */
		public function get currentFps():Number
		{
			return _currentFps;
		}
		
		/**
		 * 获取平均FPS
		 */
		public function get averageFps():Number
		{
			return _averageFps;
		}
		
		/**
		 * 获取最小FPS
		 */
		public function get minFps():Number
		{
			return _minFps == Number.MAX_VALUE ? 0 : _minFps;
		}
		
		/**
		 * 获取最大FPS
		 */
		public function get maxFps():Number
		{
			return _maxFps;
		}
		
		/**
		 * 获取总帧数
		 */
		public function get totalFrames():int
		{
			return _totalFrames;
		}
		
		/**
		 * 重写位置和尺寸设置器以同步更新文本渲染器
		 */
		override public function set x(value:Number):void
		{
			super.x = value;
			if (_textRenderer)
			{
				_textRenderer.setBounds(value + 5, _textRenderer.y, _textRenderer.width, _textRenderer.height);
			}
		}
		
		override public function set y(value:Number):void
		{
			super.y = value;
			if (_textRenderer)
			{
				_textRenderer.setBounds(_textRenderer.x, value + 5, _textRenderer.width, _textRenderer.height);
			}
		}
		
		override public function set width(value:Number):void
		{
			super.width = value;
			if (_textRenderer)
			{
				_textRenderer.setBounds(_textRenderer.x, _textRenderer.y, value - 10, _textRenderer.height);
			}
		}
		
		override public function set height(value:Number):void
		{
			super.height = value;
			if (_textRenderer)
			{
				_textRenderer.setBounds(_textRenderer.x, _textRenderer.y, _textRenderer.width, value - 10);
			}
		}
	}
}
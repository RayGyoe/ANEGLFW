package ui.core
{
	import flash.events.EventDispatcher;
	import flash.geom.Rectangle;
	import com.vsdevelop.air.extension.glfw.Gl;
	import agl.shader.Shader;

	/**
	 * UI组件基类
	 * 提供所有UI组件的基础功能，包括位置、大小、可见性、事件处理等
	 * @author Generated by AI Assistant
	 */
	public class UIComponent extends EventDispatcher
	{
		// 基础属性
		protected var _x:Number = 0;
		protected var _y:Number = 0;
		protected var _width:Number = 100;
		protected var _height:Number = 100;
		protected var _visible:Boolean = true;
		protected var _enabled:Boolean = true;
		protected var _alpha:Number = 1.0;
		
		// 渲染相关
		protected var _needsRedraw:Boolean = true;
		protected var _bounds:Rectangle;
		protected var _shader:Shader;
		
		// OpenGL资源
		protected var _VAO:int = 0;
		protected var _VBO:int = 0;
		protected var _vertices:Vector.<Number>;
		
		/**
		 * 构造函数
		 * @param x X坐标
		 * @param y Y坐标
		 * @param width 宽度
		 * @param height 高度
		 */
		public function UIComponent(x:Number = 0, y:Number = 0, width:Number = 100, height:Number = 100)
		{
			super();
			_x = x;
			_y = y;
			_width = width;
			_height = height;
			_bounds = new Rectangle(x, y, width, height);
			
			initializeGL();
		}
		
		/**
		 * 初始化OpenGL资源
		 */
		protected function initializeGL():void
		{
			// 创建顶点数组对象和缓冲区
			with (Gl)
			{
				_VAO = glGenVertexArrays(uint(1));
				_VBO = glGenBuffers(uint(1));
			}
			
			// 生成默认的矩形顶点数据
			updateVertices();
		}
		
		/**
		 * 更新顶点数据
		 */
		protected function updateVertices():void
		{
			// 创建矩形顶点数据 (位置 + 纹理坐标)
			_vertices = new <Number>[
				// 位置 (x, y, z)     纹理坐标 (u, v)
				_x, _y, 0,         0, 0,
				_x + _width, _y, 0, 1.0, 0,
				_x + _width, _y + _height, 0, 1, 1,
				
				_x, _y, 0,         0, 0,
				_x + _width, _y + _height, 0, 1, 1,
				_x, _y + _height, 0, 0, 1
			];
			
			updateVertexData(_vertices);
		}
		
		/**
		 * 更新顶点数据到OpenGL缓冲区
		 * @param vertices 顶点数据，如果为null则使用当前的_vertices
		 */
		protected function updateVertexData(vertices:Vector.<Number> = null):void
		{
			if (vertices != null)
			{
				_vertices = vertices;
			}
			
			if (_vertices == null) return;
			
			// 更新OpenGL缓冲区
			with (Gl)
			{
				glBindVertexArray(uint(_VAO));
				glBindBuffer(GL_ARRAY_BUFFER, uint(_VBO));
				glBufferData(GL_ARRAY_BUFFER, uint(4 * _vertices.length), _vertices, GL_DYNAMIC_DRAW);
				
				// 设置顶点属性指针
				// 位置属性
				glVertexAttribPointer(uint(0), 3, GL_FLOAT, GL_FALSE, uint(5 * 4), uint(0));
				glEnableVertexAttribArray(uint(0));
				
				// 纹理坐标属性
				glVertexAttribPointer(uint(1), 2, GL_FLOAT, GL_FALSE, uint(5 * 4), uint(3 * 4));
				glEnableVertexAttribArray(uint(1));
				
				glBindVertexArray(uint(0));
			}
			_needsRedraw = false;
		}
		
		/**
		 * 渲染组件
		 */
		public function render():void
		{
			if (!_visible || _alpha <= 0) return;
			
			if (_needsRedraw)
			{
				updateVertices();
			}
			
			// 子类实现具体的渲染逻辑
			doRender();
		}
		
		/**
		 * 子类重写此方法实现具体的渲染逻辑
		 */
		protected function doRender():void
		{
			// 默认实现：绘制一个简单的矩形
			if (_shader)
			{
				_shader.useProgram();
				with (Gl)
				{
					glBindVertexArray(uint(_VAO));
					glDrawArrays(GL_TRIANGLES, uint(0), uint(6));
					glBindVertexArray(uint(0));
				}
			}
		}
		
		/**
		 * 检查点是否在组件内
		 * @param pointX X坐标
		 * @param pointY Y坐标
		 * @return 是否在组件内
		 */
		public function hitTest(pointX:Number, pointY:Number):Boolean
		{
			return _visible && _enabled && 
				   pointX >= _x && pointX <= _x + _width &&
				   pointY >= _y && pointY <= _y + _height;
		}
		
		/**
		 * 释放OpenGL资源
		 */
		public function dispose():void
		{
			if (_VAO > 0)
			{
				var arrays:Vector.<uint> = new Vector.<uint>(1);
				arrays[0] = _VAO;
				Gl.glDeleteVertexArrays(uint(1), arrays);
				_VAO = 0;
			}
			
			if (_VBO > 0)
			{
				Gl.glDeleteBuffers(uint(1), _VBO);
				_VBO = 0;
			}
		}
		
		// 属性访问器
		public function get x():Number { return _x; }
		public function set x(value:Number):void
		{
			if (_x != value)
			{
				_x = value;
				_bounds.x = value;
				_needsRedraw = true;
			}
		}
		
		public function get y():Number { return _y; }
		public function set y(value:Number):void
		{
			if (_y != value)
			{
				_y = value;
				_bounds.y = value;
				_needsRedraw = true;
			}
		}
		
		public function get width():Number { return _width; }
		public function set width(value:Number):void
		{
			if (_width != value)
			{
				_width = value;
				_bounds.width = value;
				_needsRedraw = true;
			}
		}
		
		public function get height():Number { return _height; }
		public function set height(value:Number):void
		{
			if (_height != value)
			{
				_height = value;
				_bounds.height = value;
				_needsRedraw = true;
			}
		}
		
		public function get visible():Boolean { return _visible; }
		public function set visible(value:Boolean):void { _visible = value; }
		
		public function get enabled():Boolean { return _enabled; }
		public function set enabled(value:Boolean):void { _enabled = value; }
		
		public function get alpha():Number { return _alpha; }
		public function set alpha(value:Number):void { _alpha = Math.max(0, Math.min(1, value)); }
		
		public function get bounds():Rectangle { return _bounds.clone(); }
		
		/**
		 * 设置着色器
		 * @param shader 着色器对象
		 */
		public function setShader(shader:Shader):void
		{
			_shader = shader;
		}
	}
}
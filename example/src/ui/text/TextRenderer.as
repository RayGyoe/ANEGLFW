package ui.text
{
	import flash.display.BitmapData;
	import flash.text.TextField;
	import flash.text.TextFormat;
	import flash.text.AntiAliasType;
	import flash.utils.ByteArray;
	import flash.utils.Endian;
	import com.vsdevelop.air.extension.glfw.Gl;
	import agl.shader.Shader;
	import agl.utils.Matrix4;
	import ui.core.UIComponent;
	
	/**
	 * 文本渲染器类
	 * 继承自UIComponent，提供基于OpenGL纹理的文本渲染功能
	 * @author Generated by AI Assistant
	 */
	public class TextRenderer extends UIComponent
	{
		// 文本属性
		private var _text:String = "";
		private var _fontSize:Number = 16;
		private var _fontColor:int = 0xFFFFFF;
		private var _fontName:String = "微软雅黑";
		
		// 纹理相关
		private var _textTexture:int = 0;
		private var _textWidth:Number = 0;
		private var _textHeight:Number = 0;
		private var _textureWidth:Number = 0;  // 实际纹理宽度
		private var _textureHeight:Number = 0; // 实际纹理高度
		private var _isTextureReady:Boolean = false;
		
		// OpenGL资源
		private var _textVAO:int = 0;
		private var _textVBO:int = 0;
		private var _textVertices:Vector.<Number>;
		
		// 着色器资源
		[Embed(source="../../assets/ui/ui_vertex.glsl", mimeType="application/octet-stream")]
		private var VertexShaderSource:Class;
		
		[Embed(source="../../assets/ui/ui_fragment.glsl", mimeType="application/octet-stream")]
		private var FragmentShaderSource:Class;
		
		/**
		 * 构造函数
		 * @param x X坐标
		 * @param y Y坐标
		 * @param width 宽度
		 * @param height 高度
		 */
		public function TextRenderer(x:Number = 0, y:Number = 0, width:Number = 100, height:Number = 30)
		{
			super(x, y, width, height);
			initializeTextGL();
			// 初始化着色器
			initializeShader();
		}
		
		/**
		 * 初始化文本渲染的OpenGL资源
		 */
		private function initializeTextGL():void
		{
			with (Gl)
			{
				// 生成纹理
				_textTexture = glGenTextures(1);
				
				// 生成VAO和VBO
				_textVAO = glGenVertexArrays(1);
				_textVBO = glGenBuffers(1);
				
				// 绑定VAO
				glBindVertexArray(_textVAO);
				
				// 绑定VBO
				glBindBuffer(GL_ARRAY_BUFFER, _textVBO);
				
				// 设置顶点属性
				// 位置属性 (location = 0)
				glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * 4, 0);
				glEnableVertexAttribArray(0);
				
				// 纹理坐标属性 (location = 1)
				glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * 4, 3 * 4);
				glEnableVertexAttribArray(1);
				
				glBindVertexArray(0);
			}
		}
		/**
		 * 初始化着色器
		 */
		private function initializeShader():void
		{
			
			// 创建着色器
			var vs:String = new VertexShaderSource();
			var fs:String = new FragmentShaderSource();
			_shader = new Shader(vs, fs);
			
		}
		/**
		 * 设置文本内容
		 * @param text 文本内容
		 * @param fontSize 字体大小
		 * @param fontColor 字体颜色
		 * @param fontName 字体名称
		 */
		public function setText(text:String, fontSize:Number = 16, fontColor:int = 0xFFFFFF, fontName:String = "微软雅黑"):void
		{
			if (_text != text || _fontSize != fontSize || _fontColor != fontColor || _fontName != fontName)
			{
				_text = text;
				_fontSize = fontSize;
				_fontColor = fontColor;
				_fontName = fontName;
				
				// 重新生成文本纹理
				generateTextTexture();
				
				// 更新文本顶点数据
				updateTextVertices();
			}
		}
		
		/**
		 * 生成文本纹理
		 */
		private function generateTextTexture():void
		{
			if (!_text || _text.length == 0)
			{
				_isTextureReady = false;
				return;
			}
			
			try
			{
				// 创建TextField来渲染文本
				var textField:TextField = new TextField();
				var textFormat:TextFormat = new TextFormat();
				
				// 设置文本格式
				textFormat.font = _fontName;
				textFormat.size = _fontSize;
				textFormat.color = _fontColor;
				textFormat.bold = false;
				
				// 配置TextField
				textField.defaultTextFormat = textFormat;
				textField.text = _text;
				textField.autoSize = "left";
				//textField.antiAliasType = AntiAliasType.ADVANCED;
				textField.background = false;
				textField.border = false;
				
				// 获取文本尺寸
				_textWidth = textField.textWidth + 4; // 添加一些边距
				_textHeight = textField.textHeight + 4;
				
				// 确保尺寸是2的幂次方（对某些GPU更友好）
				_textureWidth = getNextPowerOfTwo(_textWidth);
				_textureHeight = getNextPowerOfTwo(_textHeight);
				
				// 创建BitmapData（使用完全透明的背景）
				var bitmapData:BitmapData = new BitmapData(_textureWidth, _textureHeight, true, 0x00000000);
				
				// 绘制文本到BitmapData
				bitmapData.draw(textField);
				
				// 创建OpenGL纹理
				createTextureFromBitmapData(bitmapData);
				
				// 清理资源
				bitmapData.dispose();
				
				_isTextureReady = true;
			}
			catch (error:Error)
			{
				trace("TextRenderer: 生成文本纹理失败 - " + error.message);
				_isTextureReady = false;
			}
		}
		
		/**
		 * 从BitmapData创建OpenGL纹理
		 * @param bitmapData 位图数据
		 */
		private function createTextureFromBitmapData(bitmapData:BitmapData):void
		{
			// 获取像素数据
			var pixels:ByteArray = new ByteArray();
			pixels.endian = Endian.LITTLE_ENDIAN;
			bitmapData.copyPixelsToByteArray(bitmapData.rect, pixels);
			pixels.position = 0;
			
			with (Gl)
			{
				// 绑定纹理
				glBindTexture(GL_TEXTURE_2D, _textTexture);
				
				// 设置纹理参数
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
				
				// 上传纹理数据
				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, bitmapData.width, bitmapData.height, 0, GL_BGRA, GL_UNSIGNED_BYTE, pixels);
				
				glBindTexture(GL_TEXTURE_2D, 0);
			}
		
		}
		
		/**
		 * 获取下一个2的幂次方数
		 * @param value 输入值
		 * @return 2的幂次方数
		 */
		private function getNextPowerOfTwo(value:Number):int
		{
			var power:int = 1;
			while (power < value)
			{
				power *= 2;
			}
			return power;
		}
		
		/**
		 * 设置组件边界
		 * @param x X坐标
		 * @param y Y坐标
		 * @param width 宽度
		 * @param height 高度
		 */
		public function setBounds(x:Number, y:Number, width:Number, height:Number):void
		{
			// 更新位置和尺寸属性
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			
			// 更新文本顶点数据
			updateTextVertices();
		}
		
		/**
		 * 更新文本顶点数据
		 */
		private function updateTextVertices():void
		{
			if (!_isTextureReady) return;
			
			// 计算文本位置 - 左对齐，顶部对齐
			var textX:Number = _x;
			var textY:Number = _y;
			
			// 计算纹理坐标比例（修正因2的幂次方调整导致的变形）
			var texCoordU:Number = _textWidth / _textureWidth;   // U坐标范围
			var texCoordV:Number = _textHeight / _textureHeight; // V坐标范围
			
			// 创建顶点数据（位置 + 纹理坐标）
			// 注意：翻转Y轴纹理坐标以修正OpenGL和Flash坐标系差异
			_textVertices = new <Number>[
											// 第一个三角形
											textX, textY, 0.0, 0.0, 0.0,                           // 左上 (纹理坐标Y翻转)
											textX + _textWidth, textY, 0.0, texCoordU, 0.0,        // 右上 (纹理坐标Y翻转)
											textX, textY + _textHeight, 0.0, 0.0, texCoordV,      // 左下 (纹理坐标Y翻转)
											
											// 第二个三角形
											textX + _textWidth, textY, 0.0, texCoordU, 0.0,        // 右上 (纹理坐标Y翻转)
											textX + _textWidth, textY + _textHeight, 0.0, texCoordU, texCoordV, // 右下 (纹理坐标Y翻转)
											textX, textY + _textHeight, 0.0, 0.0, texCoordV       // 左下 (纹理坐标Y翻转)
			];
			
			with (Gl) 
			{
				// 更新VBO
				glBindBuffer(GL_ARRAY_BUFFER, _textVBO);
				glBufferData(GL_ARRAY_BUFFER, _textVertices.length * 4, _textVertices, GL_DYNAMIC_DRAW);
				glBindBuffer(GL_ARRAY_BUFFER, 0);
			}
			
		}
		
		/**
		 * 重写doRender方法以实现文本渲染
		 */
		override protected function doRender():void
		{
			if (!_isTextureReady || !_text || _text.length == 0) return;
			
			// 设置着色器参数（如果有着色器的话）
			if (_shader) {
				_shader.useProgram();
				
				// 设置模型矩阵（单位矩阵）
				var modelMatrix:Matrix4 = new Matrix4();
				modelMatrix.identity();
				_shader.setMatrix4fv("uModel", modelMatrix);
				
				// 设置投影矩阵（从UIManager获取）
				var uiManager:ui.core.UIManager = ui.core.UIManager.getInstance();
				_shader.setMatrix4fv("uProjection", uiManager.projectionMatrix);
			}
			
			with (Gl)
			{
				// 设置颜色（白色，让纹理颜色显示）
				glUniform4f(glGetUniformLocation(_shader.program, "uColor"), 1.0, 1.0, 1.0, 1.0);
				
				// 设置透明度
				glUniform1f(glGetUniformLocation(_shader.program, "uAlpha"), alpha);
				
				// 启用纹理
				glUniform1i(glGetUniformLocation(_shader.program, "uUseTexture"), 1);
				
				// 绑定纹理
				glActiveTexture(GL_TEXTURE0);
				glBindTexture(GL_TEXTURE_2D, _textTexture);
				glUniform1i(glGetUniformLocation(_shader.program, "uTexture"), 0);
				
				// 启用混合以支持透明度
				glEnable(GL_BLEND);
				glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
				
				// 绘制文本
				glBindVertexArray(_textVAO);
				glDrawArrays(GL_TRIANGLES, 0, 6);
				glBindVertexArray(0);
				
				// 禁用混合
				glDisable(GL_BLEND);
				
				// 解绑纹理
				glBindTexture(GL_TEXTURE_2D, 0);
			}
		
		}
		
		
		/**
		 * 重写dispose方法以释放文本渲染资源
		 */
		override public function dispose():void
		{
			with (Gl)
			{
				if (_textTexture > 0)
				{
					glDeleteTextures(1, new Vector.<uint>[_textTexture]);
					_textTexture = 0;
				}
				
				if (_textVAO > 0)
				{
					glDeleteVertexArrays(1, new <uint>[_textVAO]);
					_textVAO = 0;
				}
				
				if (_textVBO > 0)
				{
		
					glDeleteBuffers(1, _textVBO);
					_textVBO = 0;
				}
			}
			
			_isTextureReady = false;
			
			// 调用父类的dispose方法
			super.dispose();
		}
		
		/**
		 * 设置渲染边界（为Button组件提供的接口）
		 * @param x X坐标
		 * @param y Y坐标
		 * @param width 宽度
		 * @param height 高度
		 */
		public function setRenderBounds(x:Number, y:Number, width:Number, height:Number):void
		{
			setBounds(x, y, width, height);
		}
		
		/**
		 * 设置背景颜色（为Button组件提供的接口）
		 * @param color 背景颜色
		 */
		public function setBackgroundColor(color:Vector.<Number>):void
		{
			// TextRenderer不需要背景颜色，因为它只渲染文本
			// 这个方法是为了兼容Button组件的调用
		}
		
		
		
		// 属性访问器
		public function get text():String  { return _text; }
		
		public function get textWidth():Number  { return _textWidth; }
		
		public function get textHeight():Number  { return _textHeight; }
		
		public function get isReady():Boolean  { return _isTextureReady; }
	}
}